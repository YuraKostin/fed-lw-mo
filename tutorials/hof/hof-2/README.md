# HOF: Функции высшего порядка (higher-order function). Часть 2

## Фильтруем массив

В [прошлой](../hof-1) статье мы познакомились с возможностью
возвращать функцию, как результат работы функции.

Давайте теперь напишем что-нибудь полезное.

Представим, что у нас есть яблоки. Мы очень хотим их съесть, но
есть один нюанс: некоторые яблоки могут быть червивыми.
Хорошо бы заранее знать, какие...

Опишем два яблока следующим образом:

```javascript
const apple = {
    color: 'green',
    size: 'medium',
    wormEaten: false,
}; // среднего размера, зелёного цвета, не червивое

const wormEatenApple = {
    color: 'red',
    size: 'big',
    wormEaten: true,
}; // большое, красное, червивое... увы...
```

Как нам проверить, червивые яблоки, или нет? Прочитать свойство `wormEaten`.

```javascript
const isWormEatenApple1 = apple.wormEaten;
const isWormEatenApple2 = wormEatenApple.wormEaten;


console.log(`Яблоко(apple) ${isWormEatenApple1 ? 'червивое' : 'не червивое'}`);
console.log(`Яблоко(wormEatenApple) ${isWormEatenApple2 ? 'червивое' : 'не червивое'}`);
```

Читать свойство каждый раз - не очень удобно. 
Можно как минимум ошибиться при его - свойства - наборе.
Давайте добавим функция для определения червивости.

```javascript
const isWormEaten = apple => apple.wormEaten;
```

Выглядит функция довольно просто, но мы уже немного 
убрали дублирование кода, и можем ещё, но всё по порядку.

Теперь определять червивость стало чуть-чуть проще.

```javascript
alert(`Яблоко - apple - ${isWormEaten(apple) ? 'червивое' : 'не червивое'}`);
```

Всё замечательно, но что, если яблок будет не 1, не 2, а 10, 100, 1000?
Складывать каждый объект-яблоко в отдельную переменную будет крайне неудобно.

Что бы мы могли использовать для удобного хранения 
большого количества одинаковых сущностей? Правильно, массив!
Сложим яблоки в него.

```javascript
const apples = [
    apple, 
    wormEatenApple,
];
```

Но, может быть скажете вы "Теперь нужно обращаться к каждому яблоку
по индексу!". И будете правы. Однако наша цель не перебирать все
яблоки руками. Мы хотим иметь удобную машину, которая будет делать это за
нас, и возвращать нам только нечервивые яблоки.

Разумеется, для работы с массивом удобнее всего использовать циклы.
Попробуем получить массив не червивых яблок.

```javascript
const nonWormEatenApples = [];

for (let i = 0; i < apples.length; i++) {
    const apple = apples[i];
    // Если яблоко не червивое
    if (!isWormEaten(apple)) {
        // Добавляем его в массив
        nonWormEatenApples.push(apple);
    }
}

console.log(nonWormEatenApples);
```

В консоли выведется массив из одного элемента - объекта-яблока, которое
не является червивым.

И на этом статья бы могла и завершиться, если бы не столько лишних строк
кода, которые мы написали выше.

Если задуматься, то наш цикл занимается тем, что __фильтрует__ яблоки(
набор каких-то сущностей
) на тему червивости(по определённому признаку).

Это три важных пункта, на основе которых мы будем переписывать наш код.
Итак, нам нужна функция, которая будет знать **как** фильтровать, и 
**что** фильтровать.

```javascript
const filter => (howToFilter, whatToFilter) => {
    // ...
};
```

И соединим её с описанным ранее `for` циклом.

```javascript
const filter = (howToFilter, whatToFilter) => {
    const result = [];
    
    for (let i = 0; i < whatToFilter.length; i++) {
        const item = whatToFilter[i];
        
        // Если сущность проходит проверку фильтрующей функцией
        if (howToFilter(item)) {
            // Добавляем сущность в массив
            result.push(item);
        }
    }
    // Возвращаем из функции отфильтрованные сущности
    return result;
};

const wormEatenApples = filter(isWormEaten, apples); // Яблоки, поеденные червями

console.log(wormEatenApples);
```

Функцию необязательно создавать и хранить отдельно: в функцию `filter` 
можно передавать анонимные функции.

```javascript
const array = [1,2,3,4,5,6,7,8,9];
const odd = filter((item) => item % 2 === 0, array);

console.log('Чётные числа из массива array', odd);
```

