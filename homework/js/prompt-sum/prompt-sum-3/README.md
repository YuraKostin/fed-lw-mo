# Работа с пользовательским вводом. Сложение чисел. Часть 3

Так мы добились того, чего хотели.

Разрабатывая, мы не допустим ошибку, передавая в функцию **не** числа,
а значит, когда пользователь воспользуется нашим интерфейсом, всё
отработает так как надо.

Теперь, при вызове функции, мы снова оборачиваем аргументы в 
функцию `Number`.

Всё работает отлично, если мы вписываем в `prompt` числа.
Но если ввести **не** число, то нас ждёт неожиданное поведение. 
В результате функция сработает и не вызовет выброса исключения, 
а в `alert`-е будет выведено `NaN`, что означает `not a number`.

Почему же не выбрасывается исключение? Потому, что `typeof NaN`
возвращает `'number'`. 

Откуда взялось `NaN`? 

В нашем случае, при попытке преобразовать симольную строку в число, 
значение преобразовывается в `NaN`.

## Задача

Добавить проверку на `NaN` значение.

_* Со звёздочкой:_

Теперь, когда наша функция ругается на невалидные данные, нам будет
просто об этом узнать на этапе разработки, и код с ошибкой не попадёт в 
production.

Но возникает несколько вопросов:
* должны ли мы обрабатывать исключение (используя `try/catch`), 
чтобы сообщить пользователю об ошибке введённых данных? 
* или выполнять повторную проверку данных до вызова целевой функции?

Дополнительно:
* Что будет, если оставить только проверку на `NaN`?